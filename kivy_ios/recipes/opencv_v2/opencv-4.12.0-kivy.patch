diff --git a/modules/python/src2/gen2.py b/modules/python/src2/gen2.py
index 7d9f75063c..dbb3e6148d 100755
--- a/modules/python/src2/gen2.py
+++ b/modules/python/src2/gen2.py
@@ -1,11 +1,17 @@
 #!/usr/bin/env python
 
 from __future__ import print_function
+
+import shlex
+
 import hdr_parser, sys, re
 import json
 from string import Template
 from collections import namedtuple
 from itertools import chain
+import os
+from pathlib import Path
+from typing import Dict, Iterable, Tuple
 
 from typing_stubs_generator import TypingStubsGenerator
 
@@ -20,6 +26,7 @@ if sys.version_info >= (3, 6):
 else:
     SymbolName = namedtuple('SymbolName', ('namespaces', 'classes', 'name'))
 
+
     def parse_symbol_name(cls, full_symbol_name, known_namespaces):
         chunks = full_symbol_name.split('.')
         namespaces, name = chunks[:-1], chunks[-1]
@@ -28,8 +35,8 @@ else:
             classes.insert(0, namespaces.pop())
         return cls(tuple(namespaces), tuple(classes), name)
 
-    setattr(SymbolName, "parse", classmethod(parse_symbol_name))
 
+    setattr(SymbolName, "parse", classmethod(parse_symbol_name))
 
 forbidden_arg_types = ["void*"]
 
@@ -138,7 +145,6 @@ ${methods_inits}
 };
 """)
 
-
 gen_template_get_prop = Template("""
 static PyObject* pyopencv_${name}_get_${member}(pyopencv_${name}_t* p, void *closure)
 {
@@ -186,7 +192,6 @@ static int pyopencv_${name}_set_${member}(pyopencv_${name}_t* p, PyObject *value
 }
 """)
 
-
 gen_template_prop_init = Template("""
     {(char*)"${export_member_name}", (getter)pyopencv_${name}_get_${member}, NULL, (char*)"${export_member_name}", NULL},""")
 
@@ -234,7 +239,8 @@ simple_argtype_mapping = {
     "Stream": ArgTypeInfo("Stream", FormatStrings.object, 'Stream::Null()', True),
     "cuda_Stream": ArgTypeInfo("cuda::Stream", FormatStrings.object, "cuda::Stream::Null()", True),
     "cuda_GpuMat": ArgTypeInfo("cuda::GpuMat", FormatStrings.object, "cuda::GpuMat()", True),
-    "UMat": ArgTypeInfo("UMat", FormatStrings.object, 'UMat()', True),  # FIXIT: switch to CV_EXPORTS_W_SIMPLE as UMat is already a some kind of smart pointer
+    "UMat": ArgTypeInfo("UMat", FormatStrings.object, 'UMat()', True),
+    # FIXIT: switch to CV_EXPORTS_W_SIMPLE as UMat is already a some kind of smart pointer
 }
 
 # Set of reserved keywords for Python. Can be acquired via the following call
@@ -243,7 +249,7 @@ simple_argtype_mapping = {
 # used as variables identifiers
 python_reserved_keywords = {
     "True", "None", "False", "as", "assert", "def", "del", "elif", "except", "exec",
-    "finally", "from", "global",  "import", "in", "is", "lambda", "nonlocal",
+    "finally", "from", "global", "import", "in", "is", "lambda", "nonlocal",
     "pass", "print", "raise", "with", "yield"
 }
 
@@ -308,10 +314,11 @@ class ClassInfo(object):
         if decl:
             bases = decl[1].split()[1:]
             if len(bases) > 1:
-                print("Note: Class %s has more than 1 base class (not supported by Python C extensions)" % (self.cname,))
+                print(
+                    "Note: Class %s has more than 1 base class (not supported by Python C extensions)" % (self.cname,))
                 print("      Bases: ", " ".join(bases))
                 print("      Only the first base class will be used")
-                #return sys.exit(-1)
+                # return sys.exit(-1)
             elif len(bases) == 1:
                 self.base = bases[0].strip(",")
                 if self.base.startswith("cv::"):
@@ -365,8 +372,9 @@ class ClassInfo(object):
 
     def gen_map_code(self, codegen):
         all_classes = codegen.classes
-        code = "static bool pyopencv_to(PyObject* src, %s& dst, const ArgInfo& info)\n{\n    PyObject* tmp;\n    bool ok;\n" % (self.cname)
-        code += "".join([gen_template_set_prop_from_map.substitute(propname=p.name,proptype=p.tp) for p in self.props])
+        code = "static bool pyopencv_to(PyObject* src, %s& dst, const ArgInfo& info)\n{\n    PyObject* tmp;\n    bool ok;\n" % (
+            self.cname)
+        code += "".join([gen_template_set_prop_from_map.substitute(propname=p.name, proptype=p.tp) for p in self.props])
         if self.base:
             code += "\n    return pyopencv_to_safe(src, (%s&)dst, info);\n}\n" % all_classes[self.base].cname
         else:
@@ -390,17 +398,24 @@ class ClassInfo(object):
 
         for pname, p in sorted_props:
             if self.isalgorithm:
-                getset_code.write(gen_template_get_prop_algo.substitute(name=self.name, cname=self.cname, member=pname, membertype=p.tp, access=access_op))
+                getset_code.write(gen_template_get_prop_algo.substitute(name=self.name, cname=self.cname, member=pname,
+                                                                        membertype=p.tp, access=access_op))
             else:
-                getset_code.write(gen_template_get_prop.substitute(name=self.name, member=pname, membertype=p.tp, access=access_op))
+                getset_code.write(
+                    gen_template_get_prop.substitute(name=self.name, member=pname, membertype=p.tp, access=access_op))
             if p.readonly:
-                getset_inits.write(gen_template_prop_init.substitute(name=self.name, member=pname, export_member_name=p.export_name))
+                getset_inits.write(
+                    gen_template_prop_init.substitute(name=self.name, member=pname, export_member_name=p.export_name))
             else:
                 if self.isalgorithm:
-                    getset_code.write(gen_template_set_prop_algo.substitute(name=self.name, cname=self.cname, member=pname, membertype=p.tp, access=access_op))
+                    getset_code.write(
+                        gen_template_set_prop_algo.substitute(name=self.name, cname=self.cname, member=pname,
+                                                              membertype=p.tp, access=access_op))
                 else:
-                    getset_code.write(gen_template_set_prop.substitute(name=self.name, member=pname, membertype=p.tp, access=access_op))
-                getset_inits.write(gen_template_rw_prop_init.substitute(name=self.name, member=pname, export_member_name=p.export_name))
+                    getset_code.write(gen_template_set_prop.substitute(name=self.name, member=pname, membertype=p.tp,
+                                                                       access=access_op))
+                getset_inits.write(gen_template_rw_prop_init.substitute(name=self.name, member=pname,
+                                                                        export_member_name=p.export_name))
 
         methods_code = StringIO()
         methods_inits = StringIO()
@@ -527,10 +542,10 @@ class ArgInfo(object):
         return self.tp in ["Mat", "vector_Mat",
                            "cuda::GpuMat", "cuda_GpuMat", "GpuMat",
                            "vector_GpuMat", "vector_cuda_GpuMat",
-                           "UMat", "vector_UMat"] # or self.tp.startswith("vector")
+                           "UMat", "vector_UMat"]  # or self.tp.startswith("vector")
 
     def crepr(self):
-        arg  = 0x01 if self.outputarg else 0x0
+        arg = 0x01 if self.outputarg else 0x0
         arg += 0x02 if self.arithm_op_src_arg else 0x0
         arg += 0x04 if self.pathlike else 0x0
         arg += 0x08 if self.nd_mat else 0x0
@@ -607,7 +622,7 @@ class FuncVariant(object):
         for arg_decl in decl[3]:
             assert len(arg_decl) == 4, \
                 'ArgInfo contract is violated. Arg declaration should contain:' \
-                '"arg_type", "name", "default_value", "modifiers". '\
+                '"arg_type", "name", "default_value", "modifiers". ' \
                 'Got tuple: {}'.format(arg_decl)
 
             ainfo = ArgInfo(atype=arg_decl[0], name=arg_decl[1],
@@ -671,7 +686,7 @@ class FuncVariant(object):
         # to the main arguments list
         argument_names = tuple(arg.name for arg in arguments)
         assert len(set(argument_names)) == len(argument_names), \
-            "Duplicate arguments with names '{}' in function '{}'. "\
+            "Duplicate arguments with names '{}' in function '{}'. " \
             "Please, check named arguments used in function interface".format(
                 argument_names, self.name
             )
@@ -771,13 +786,13 @@ class FuncInfo(object):
         if self.is_static:
             name += "_static"
 
-        return "pyopencv_" + self.namespace.replace('.','_') + '_' + classname + name
+        return "pyopencv_" + self.namespace.replace('.', '_') + '_' + classname + name
 
     def get_wrapper_prototype(self, codegen):
         full_fname = self.get_wrapper_name()
         if self.isconstructor:
             return "static int {fn_name}(pyopencv_{type_name}_t* self, PyObject* py_args, PyObject* kw)".format(
-                    fn_name=full_fname, type_name=codegen.classes[self.classname].name)
+                fn_name=full_fname, type_name=codegen.classes[self.classname].name)
 
         if self.classname:
             self_arg = "self"
@@ -807,7 +822,7 @@ class FuncInfo(object):
             s = self.variants[idx].py_prototype
             p1 = s.find("(")
             p2 = s.rfind(")")
-            prototype_list = [s[:p1+1] + "[" + s[p1+1:p2] + "]" + s[p2:]]
+            prototype_list = [s[:p1 + 1] + "[" + s[p1 + 1:p2] + "]" + s[p2:]]
 
         # The final docstring will be: Each prototype, followed by
         # their relevant doxygen comment
@@ -827,8 +842,8 @@ class FuncInfo(object):
         full_docstring = full_docstring.encode('ascii', errors='xmlcharrefreplace').decode()
 
         return Template('    {"$py_funcname", CV_PY_FN_WITH_KW_($wrap_funcname, $flags), "$py_docstring"},\n'
-                        ).substitute(py_funcname = self.variants[0].wname, wrap_funcname=self.get_wrapper_name(),
-                                     flags = 'METH_STATIC' if self.is_static else '0', py_docstring = full_docstring)
+                        ).substitute(py_funcname=self.variants[0].wname, wrap_funcname=self.get_wrapper_name(),
+                                     flags='METH_STATIC' if self.is_static else '0', py_docstring=full_docstring)
 
     def gen_code(self, codegen):
         all_classes = codegen.classes
@@ -864,7 +879,7 @@ class FuncInfo(object):
             hasUMat = False
             for a in v.args:
                 hasUMat = hasUMat or "UMat" in a.tp
-            if hasUMat :
+            if hasUMat:
                 variants_umat.append(v)
             else:
                 variants.append(v)
@@ -915,7 +930,8 @@ class FuncInfo(object):
                 else:
                     if tp in all_classes:
                         tp_classinfo = all_classes[tp]
-                        cname_of_value = tp_classinfo.cname if tp_classinfo.issimple else "Ptr<{}>".format(tp_classinfo.cname)
+                        cname_of_value = tp_classinfo.cname if tp_classinfo.issimple else "Ptr<{}>".format(
+                            tp_classinfo.cname)
                         arg_type_info = ArgTypeInfo(cname_of_value, FormatStrings.object, defval0, True)
                         assert not (a.is_smart_ptr and tp_classinfo.issimple), "Can't pass 'simple' type as Ptr<>"
                         if not a.is_smart_ptr and not tp_classinfo.issimple:
@@ -1049,14 +1065,15 @@ class FuncInfo(object):
                     code_ret = "return pyopencv_from(%s)" % (aname,)
             else:
                 # there is more than 1 return parameter; form the tuple out of them
-                fmtspec = "N"*len(v.py_outlist)
+                fmtspec = "N" * len(v.py_outlist)
                 code_ret = "return Py_BuildValue(\"(%s)\", %s)" % \
-                    (fmtspec, ", ".join(["pyopencv_from(" + aname + ")" for aname, argno in v.py_outlist]))
+                           (fmtspec, ", ".join(["pyopencv_from(" + aname + ")" for aname, argno in v.py_outlist]))
 
             all_code_variants.append(gen_template_func_body.substitute(code_decl=code_decl,
-                code_parse=code_parse, code_prelude=code_prelude, code_fcall=code_fcall, code_ret=code_ret))
+                                                                       code_parse=code_parse, code_prelude=code_prelude,
+                                                                       code_fcall=code_fcall, code_ret=code_ret))
 
-        if len(all_code_variants)==1:
+        if len(all_code_variants) == 1:
             # if the function/method has only 1 signature, then just put it
             code += all_code_variants[0]
         else:
@@ -1074,12 +1091,12 @@ class FuncInfo(object):
 
         cname = self.cname
         classinfo = None
-        #dump = False
-        #if dump: pprint(vars(self))
-        #if dump: pprint(vars(self.variants[0]))
+        # dump = False
+        # if dump: pprint(vars(self))
+        # if dump: pprint(vars(self.variants[0]))
         if self.classname:
             classinfo = all_classes[self.classname]
-            #if dump: pprint(vars(classinfo))
+            # if dump: pprint(vars(classinfo))
             if self.isconstructor:
                 py_name = classinfo.full_export_name
             else:
@@ -1089,7 +1106,7 @@ class FuncInfo(object):
                 cname = classinfo.cname + '::' + cname
         else:
             py_name = '.'.join([self.namespace, self.variants[0].wname])
-        #if dump: print(cname + " => " + py_name)
+        # if dump: print(cname + " => " + py_name)
         py_signatures = codegen.py_signatures.setdefault(cname, [])
         for v in self.variants:
             s = dict(name=py_name, arg=v.py_arg_str, ret=v.py_return_str)
@@ -1110,7 +1127,7 @@ class Namespace(object):
 
 class PythonWrapperGenerator(object):
     class Config:
-        def __init__(self, headers, preprocessor_definitions = None):
+        def __init__(self, headers, preprocessor_definitions=None):
             self.headers = headers
             if preprocessor_definitions is None:
                 preprocessor_definitions = {}
@@ -1147,7 +1164,7 @@ class PythonWrapperGenerator(object):
 
         if classinfo.name in self.classes:
             print("Generator error: class %s (cname=%s) already exists" \
-                % (classinfo.name, classinfo.cname))
+                  % (classinfo.name, classinfo.cname))
             sys.exit(-1)
         self.classes[classinfo.name] = classinfo
 
@@ -1161,7 +1178,7 @@ class PythonWrapperGenerator(object):
         py_name = classinfo.full_export_name  # use wrapper name
         py_signatures = self.py_signatures.setdefault(classinfo.cname, [])
         py_signatures.append(dict(name=py_name))
-        #print('class: ' + classinfo.cname + " => " + py_name)
+        # print('class: ' + classinfo.cname + " => " + py_name)
 
     def get_export_scope_name(self, original_scope_name):
         # Outer classes should be registered before their content - inner classes in this case
@@ -1179,26 +1196,26 @@ class PythonWrapperGenerator(object):
         return SymbolName.parse(name, self.parser.namespaces)
 
     def add_const(self, name, decl):
-        cname = name.replace('.','::')
+        cname = name.replace('.', '::')
         namespace, classes, name = self.split_decl_name(name)
         namespace = '.'.join(namespace)
-        name = '_'.join(chain(classes, (name, )))
+        name = '_'.join(chain(classes, (name,)))
         ns = self.namespaces.setdefault(namespace, Namespace())
         if name in ns.consts:
             print("Generator error: constant %s (cname=%s) already exists" \
-                % (name, cname))
+                  % (name, cname))
             sys.exit(-1)
         ns.consts[name] = cname
         value = decl[1]
         py_name = '.'.join([namespace, name])
         py_signatures = self.py_signatures.setdefault(cname, [])
         py_signatures.append(dict(name=py_name, value=value))
-        #print(cname + ' => ' + str(py_name) + ' (value=' + value + ')')
+        # print(cname + ' => ' + str(py_name) + ' (value=' + value + ')')
 
     def add_enum(self, name, decl):
         enumeration_name = SymbolName.parse(name, self.parser.namespaces)
         is_scoped_enum = decl[0].startswith("enum class") \
-            or decl[0].startswith("enum struct")
+                         or decl[0].startswith("enum struct")
 
         wname = normalize_class_name(name)
         if wname.endswith("<unnamed>"):
@@ -1220,12 +1237,12 @@ class PythonWrapperGenerator(object):
 
     def add_func(self, decl):
         namespace, classes, barename = self.split_decl_name(decl[0])
-        cname = "::".join(chain(namespace, classes, (barename, )))
+        cname = "::".join(chain(namespace, classes, (barename,)))
         name = barename
         classname = ''
         bareclassname = ''
         if classes:
-            classname = normalize_class_name('.'.join(namespace+classes))
+            classname = normalize_class_name('.'.join(namespace + classes))
             bareclassname = classes[-1]
         namespace_str = '.'.join(namespace)
 
@@ -1247,7 +1264,7 @@ class PythonWrapperGenerator(object):
                 return
 
         if isconstructor:
-            name = "_".join(chain(classes[:-1], (name, )))
+            name = "_".join(chain(classes[:-1], (name,)))
 
         if is_static:
             # Add it as a method to the class
@@ -1256,17 +1273,17 @@ class PythonWrapperGenerator(object):
             func.add_variant(decl, self.classes, isphantom)
 
             # Add it as global function
-            g_name = "_".join(chain(classes, (name, )))
+            g_name = "_".join(chain(classes, (name,)))
             w_classes = []
             for i in range(0, len(classes)):
-                classes_i = classes[:i+1]
-                classname_i = normalize_class_name('.'.join(namespace+classes_i))
+                classes_i = classes[:i + 1]
+                classname_i = normalize_class_name('.'.join(namespace + classes_i))
                 w_classname = self.classes[classname_i].wname
                 namespace_prefix = normalize_class_name('.'.join(namespace)) + '_'
                 if w_classname.startswith(namespace_prefix):
                     w_classname = w_classname[len(namespace_prefix):]
                 w_classes.append(w_classname)
-            g_wname = "_".join(w_classes+[name])
+            g_wname = "_".join(w_classes + [name])
             func_map = self.namespaces.setdefault(namespace_str, Namespace()).funcs
             # Static functions should be called using class names, not like
             # module-level functions, so first step is to remove them from
@@ -1297,7 +1314,7 @@ class PythonWrapperGenerator(object):
         ns = self.namespaces[ns_name]
         wname = normalize_class_name(ns_name)
 
-        self.code_ns_reg.write('static PyMethodDef methods_%s[] = {\n'%wname)
+        self.code_ns_reg.write('static PyMethodDef methods_%s[] = {\n' % wname)
         for name, func in sorted(ns.funcs.items()):
             if func.isconstructor:
                 continue
@@ -1306,12 +1323,12 @@ class PythonWrapperGenerator(object):
         self.code_ns_reg.write('#ifdef {}\n    {}\n#endif\n'.format(custom_entries_macro, custom_entries_macro))
         self.code_ns_reg.write('    {NULL, NULL}\n};\n\n')
 
-        self.code_ns_reg.write('static ConstDef consts_%s[] = {\n'%wname)
+        self.code_ns_reg.write('static ConstDef consts_%s[] = {\n' % wname)
         for name, cname in sorted(ns.consts.items()):
-            self.code_ns_reg.write('    {"%s", static_cast<long>(%s)},\n'%(name, cname))
+            self.code_ns_reg.write('    {"%s", static_cast<long>(%s)},\n' % (name, cname))
             compat_name = re.sub(r"([a-z])([A-Z])", r"\1_\2", name).upper()
             if name != compat_name:
-                self.code_ns_reg.write('    {"%s", static_cast<long>(%s)},\n'%(compat_name, cname))
+                self.code_ns_reg.write('    {"%s", static_cast<long>(%s)},\n' % (compat_name, cname))
         custom_entries_macro = 'PYOPENCV_EXTRA_CONSTANTS_{}'.format(wname.upper())
         self.code_ns_reg.write('#ifdef {}\n    {}\n#endif\n'.format(custom_entries_macro, custom_entries_macro))
         self.code_ns_reg.write('    {NULL, 0}\n};\n\n')
@@ -1340,7 +1357,7 @@ class PythonWrapperGenerator(object):
         with open(path + "/" + name, "wt") as f:
             json.dump(value, f)
 
-    def gen(self, srcfiles, output_path, preprocessor_definitions = None):
+    def gen(self, srcfiles, output_path, preprocessor_definitions=None):
         self.clear()
         self.parser = hdr_parser.CppHeaderParser(
             generate_umat_decls=True,
@@ -1348,7 +1365,6 @@ class PythonWrapperGenerator(object):
             preprocessor_definitions=preprocessor_definitions
         )
 
-
         # step 1: scan the headers and build more descriptive maps of classes, consts, functions
         for hdr in srcfiles:
             decls = self.parser.parse(hdr)
@@ -1368,7 +1384,7 @@ class PythonWrapperGenerator(object):
                     # class/struct
                     p = name.find(" ")
                     stype = name[:p]
-                    name = name[p+1:].strip()
+                    name = name[p + 1:].strip()
                     self.add_class(stype, name, decl)
                 elif name.startswith("const"):
                     # constant
@@ -1385,32 +1401,34 @@ class PythonWrapperGenerator(object):
             if classinfo.base:
                 chunks = classinfo.base.split('_')
                 base = '_'.join(chunks)
-                while base not in self.classes and len(chunks)>1:
+                while base not in self.classes and len(chunks) > 1:
                     del chunks[-2]
                     base = '_'.join(chunks)
                 if base not in self.classes:
                     print("Generator error: unable to resolve base %s for %s"
-                        % (classinfo.base, classinfo.name))
+                          % (classinfo.base, classinfo.name))
                     sys.exit(-1)
                 base_instance = self.classes[base]
                 classinfo.base = base
                 classinfo.isalgorithm |= base_instance.isalgorithm  # wrong processing of 'isalgorithm' flag:
-                                                                    # doesn't work for trees(graphs) with depth > 2
+                # doesn't work for trees(graphs) with depth > 2
                 self.classes[name] = classinfo
 
         # tree-based propagation of 'isalgorithm'
         processed = dict()
+
         def process_isalgorithm(classinfo):
             if classinfo.isalgorithm or classinfo in processed:
                 return classinfo.isalgorithm
             res = False
             if classinfo.base:
                 res = process_isalgorithm(self.classes[classinfo.base])
-                #assert not (res == True or classinfo.isalgorithm is False), "Internal error: " + classinfo.name + " => " + classinfo.base
+                # assert not (res == True or classinfo.isalgorithm is False), "Internal error: " + classinfo.name + " => " + classinfo.base
                 classinfo.isalgorithm |= res
                 res = classinfo.isalgorithm
             processed[classinfo] = True
             return res
+
         for name, classinfo in self.classes.items():
             process_isalgorithm(classinfo)
 
@@ -1418,16 +1436,16 @@ class PythonWrapperGenerator(object):
         classlist = list(self.classes.items())
         classlist.sort()
         for name, classinfo in classlist:
-            self.code_types.write("//{}\n".format(80*"="))
+            self.code_types.write("//{}\n".format(80 * "="))
             self.code_types.write("// {} ({})\n".format(name, 'Map' if classinfo.ismap else 'Generic'))
-            self.code_types.write("//{}\n".format(80*"="))
+            self.code_types.write("//{}\n".format(80 * "="))
             self.code_types.write(classinfo.gen_code(self))
             if classinfo.ismap:
                 self.code_types.write(gen_template_map_type_cvt.substitute(name=classinfo.name, cname=classinfo.cname))
             else:
                 mappable_code = "\n".join([
-                                      gen_template_mappable.substitute(cname=classinfo.cname, mappable=mappable)
-                                          for mappable in classinfo.mappables])
+                    gen_template_mappable.substitute(cname=classinfo.cname, mappable=mappable)
+                    for mappable in classinfo.mappables])
                 code = gen_template_type_decl.substitute(
                     name=classinfo.name,
                     cname=classinfo.cname if classinfo.issimple else "Ptr<{}>".format(classinfo.cname),
@@ -1447,7 +1465,7 @@ class PythonWrapperGenerator(object):
 
             def _registerType(classinfo):
                 if classinfo.decl_idx in published_types:
-                    #print(classinfo.decl_idx, classinfo.name, ' - already published')
+                    # print(classinfo.decl_idx, classinfo.name, ' - already published')
                     # If class already registered it means that there is
                     # a correponding node in the AST. This check is partically
                     # useful for base classes.
@@ -1517,6 +1535,129 @@ class PythonWrapperGenerator(object):
         self.save_json(output_path, "pyopencv_signatures.json", self.py_signatures)
 
 
+def cv_type_specialize(output_dir: str) -> int:
+    """
+    Recursively scan output_dir and, in each .h/.hpp/.hh/.hxx/.c/.cc/.cpp/.cxx/.mm file,
+    replace bare OpenCV type names with cv::-qualified ones, avoiding double-prefixing.
+
+    Returns the total number of replacements performed.
+    """
+    # Types to qualify
+    conflict_types: Dict[str, str] = {
+        'Point': 'cv::Point',
+        'Size': 'cv::Size',
+        'Rect': 'cv::Rect',
+        'Ptr': 'cv::Ptr',
+    }
+
+    # File extensions we will edit
+    exts = {'.h', '.hpp', '.hh', '.hxx', '.c', '.cc', '.cpp', '.cxx', '.mm'}
+
+    # Precompile regex patterns with a guard to avoid already-qualified tokens.
+    # (?<!cv::) ensures we donâ€™t turn 'cv::Point' into 'cv::cv::Point'.
+    patterns: Iterable[Tuple[re.Pattern, str]] = tuple(
+        (re.compile(rf'(?<!cv::)\b{re.escape(k)}\b'), v)
+        for k, v in conflict_types.items()
+    )
+
+    # Some directories we generally don't want to touch
+    skip_dirs = {'.git', '.svn', '.hg', 'build', 'out', 'dist',
+                 'cmake-build-debug', 'cmake-build-release'}
+
+    def _read_text(p: Path) -> Tuple[str, str]:
+        """Read file with a couple of fallback encodings."""
+        for enc in ('utf-8', 'utf-8-sig', 'latin-1'):
+            try:
+                return p.read_text(encoding=enc), enc
+            except UnicodeDecodeError:
+                continue
+        # Last resort: ignore errors to avoid crashes on odd files.
+        return p.read_text(errors='ignore'), 'utf-8'
+
+    total_replacements = 0
+    output_path = Path(output_dir)
+
+    if not output_path.exists():
+        raise FileNotFoundError(f"Directory does not exist: {output_dir}")
+
+    for root, dirs, files in os.walk(output_dir):
+        # prune unwanted dirs
+        dirs[:] = [d for d in dirs if d not in skip_dirs]
+
+        for fname in files:
+            if Path(fname).suffix.lower() not in exts:
+                continue
+
+            path = Path(root) / fname
+            original_text, encoding = _read_text(path)
+
+            changed = False
+            file_replacements = 0
+            new_lines = []
+
+            for line in original_text.splitlines(keepends=True):
+                # Skip #include lines to avoid mangling headers like "Point.h"
+                if line.lstrip().startswith("#include"):
+                    new_lines.append(line)
+                    continue
+
+                new_line = line
+                for pattern, replacement in patterns:
+                    new_line, n = pattern.subn(replacement, new_line)
+                    if n:
+                        file_replacements += n
+                        changed = True
+                new_lines.append(new_line)
+
+            if changed:
+                new_text = ''.join(new_lines)
+                # Write atomically where possible
+                tmp_path = path.with_suffix(path.suffix + ".tmp")
+                tmp_path.write_text(new_text, encoding=encoding)
+                tmp_path.replace(path)
+                total_replacements += file_replacements
+                print(f"[patched] {path}  (+{file_replacements} replacements)")
+
+    print(f"Done. Total replacements: {total_replacements}")
+    return total_replacements
+
+
+def fix_destructors(path):
+    def fix_cvpy_type_sname_easy_in_text(text: str) -> str:
+        pat = re.compile(r'(CVPY_TYPE\s*\(\s*[^,]*,\s*[^,]*,\s*[^,]*,\s*)([^,\s)]+)')
+
+        def strip_cv(s: str) -> str:
+            s = re.sub(r'^(?:cv\s*::\s*)', '', s)  # cv::Foo -> Foo
+            return s
+
+        return pat.sub(lambda m: m.group(1) + strip_cv(m.group(2)), text)
+
+    orig = path.read_text(encoding='utf-8', errors='ignore')
+    new = fix_cvpy_type_sname_easy_in_text(orig)
+    if new != orig:
+        path.write_text(new, encoding='utf-8')
+        return 1
+    return 0
+
+
+def link_static(output_dir):
+    link = Path(os.path.join(output_dir, "../python3/CMakeFiles/opencv_python3.dir/link.txt"))
+    cv_libs = sorted(str(p.resolve()) for p in Path(os.path.join(output_dir, "../../lib")).glob("*.a"))
+    external_libs = sorted(str(p.resolve()) for p in Path(os.path.join(output_dir, "../../3rdparty/lib")).glob("*.a"))
+
+    cv2_objs = [
+        "CMakeFiles/opencv_python3.dir/__/src2/cv2.cpp.o",
+        "CMakeFiles/opencv_python3.dir/__/src2/cv2_util.cpp.o",
+        "CMakeFiles/opencv_python3.dir/__/src2/cv2_numpy.cpp.o",
+        "CMakeFiles/opencv_python3.dir/__/src2/cv2_convert.cpp.o",
+        "CMakeFiles/opencv_python3.dir/__/src2/cv2_highgui.cpp.o"
+    ]
+
+    cmd = ["libtool", "-static", "-o", "../../lib/python3/cv2.python3.a"] + cv2_objs + cv_libs + external_libs
+    new_line = " ".join(shlex.quote(x) for x in cmd)
+    link.write_text(new_line + "\n", encoding="utf-8")
+
+
 if __name__ == "__main__":
     import argparse
     import tempfile
@@ -1529,8 +1670,8 @@ if __name__ == "__main__":
         dest="config_json_path",
         required=False,
         help="Generator configuration file in .json format"
-        "Refer to PythonWrapperGenerator.Config for available "
-        "configuration keys"
+             "Refer to PythonWrapperGenerator.Config for available "
+             "configuration keys"
     )
     arg_parser.add_argument(
         "-o", "--output_dir",
@@ -1551,3 +1692,11 @@ if __name__ == "__main__":
     generator = PythonWrapperGenerator()
 
     generator.gen(config.headers, args.output_dir, config.preprocessor_definitions)
+    cv_type_specialize(args.output_dir)
+    script_dir = os.path.dirname(os.path.realpath(__file__))
+    cv_type_specialize(os.path.join(script_dir, '../../core/misc/python'))
+    cv_type_specialize(os.path.join(script_dir, '../../videoio/misc/python'))
+    cv_type_specialize(script_dir)
+    file = os.path.join(args.output_dir, "pyopencv_generated_types.h")
+    fix_destructors(Path(file))
+    link_static(args.output_dir)
